#!/usr/bin/env ruby
#
# = Synopsis
#
# Generate Nagios configurations from Puppet Resources in an ActiveRecord database
#
# = Usage
#
#   naggen [-h|--help] [-d|--debug] [-v|--verbose] [--compare]
#
# = Description
#
# This executable is a means of short-circuiting the process of generating nagios
# configurations on your server using Puppet Exported Resources.  It skips any possible
# naming conflicts resulting from Puppet's resource uniqueness requirements, and it
# also skips the inefficiencies involved in converting and transporting large numbers
# of Puppet resources.
#
# At the least, the machine that runs this will need ActiveRecord (2.0.2) installed,
# along with any database libraries you use.
#
# = Options
#
# Note that any configuration parameter that's valid in the configuration file
# is also a valid long argument.  For example, 'ssldir' is a valid configuration
# parameter, so you can specify '--ssldir <directory>' as an argument.
#
# You can add naggen-specific settings to your puppet.conf in a '[naggen]' section,
# just like any other executable.
#
# See the configuration file documentation at
# http://reductivelabs.com/projects/puppet/reference/configref.html for
# the full list of acceptable parameters. A commented list of all
# configuration options can also be generated by running puppet with
# '--genconfig'.
#
# compare::
#   Compare new and old files and only backup and write if the files are different.
#   Potentially expensive computationally, but idempotent.  Will exit with 0 if
#   no changes were made and 1 if there were.
#
# debug::
#   Enable full debugging.
#
# detailed-exitcodes::
#   Provide transaction information via exit codes.  If this is enabled, an exit
#   code of '2' means there were changes, and an exit code of '4' means that there
#   were failures during the transaction.
#
# help::
#   Print this help message
#
# verbose::
#   Print extra information.
#
# = Example
#
#   naggen --storeconfigs --confdir /foo --compare
#
#
# = License
#   Copyright 2011 Luke Kanies
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

require 'puppet'
require 'puppet/rails'
require 'puppet/rails/resource'
require 'puppet/rails/param_value'
require 'puppet/network/client'
require 'puppet/parser/collector'
require 'puppet/provider/naginator'
require 'getoptlong'

# Monkey-patch the rails resources so we can
# easily convert them to nagios instances.
class Puppet::Rails::Resource
    def to_param_hash
        values = @params_hash || Puppet::Rails::ParamValue.find_all_params_from_resource(self)
        if values.size == 0
            return {}
        end
        values.inject({}) do |hash, value|
            hash[value['name']] ||= []
            hash[value['name']] << value["value"]
            hash
        end
    end

    def to_nagios
        unless nagios_type = Nagios::Base.type(restype.sub("Nagios_", '').to_sym)
            raise Puppet::DevError, "Could not find nagios type '%s'" % restype
        end

        result = nagios_type.new

        to_param_hash.each do |param, value|
            next unless nagios_type.parameter?(param)
            result[param] = value
        end

        result[:name] = self.title

        result
    end
end

class NagiosWriter
    class FakeScope
        def debug(string)
            Puppet.debug string
        end

        def host
            "this host doesn't exist"
        end
    end

    attr_accessor :nagios_type, :bucket

    def backup(target)
        return unless FileTest.exist?(target) and File.stat(target).size > 0

        Puppet.info "Backing up %s" % target
        bucket.backup(target)
    end

    def collector
        collector = Puppet::Parser::Collector.new(FakeScope.new, "nagios_" + @nagios_type.to_s, nil, nil, :exported)

        # We don't have a scope, so we're stubbing everything out that would interact
        # with the scope.
        class << collector
            def collect_virtual(*args)
                []
            end

            def exported_resource(res)
                res
            end
        end

        collector
    end

    def default_target
        "/etc/nagios/nagios_#{nagios_type.to_s}.cfg"
    end

    def evaluate
        return unless resources = rails_resources()

        resources_by_target = resources.inject({}) do |hash, resource|
            target = resource["target"] || default_target
            hash[target] ||= []
            hash[target] << resource
            hash
        end

        changed = false
        resources_by_target.each do |target, resources|
            begin
                result = write(target, resources)
            rescue => detail
                $stderr.puts detail.backtrace
                Puppet.err "Could not write to %s: %s" % [target, detail]
            end

            changed = true if result
        end

        changed
    end

    def initialize(nagios_type)
        @nagios_type = nagios_type

        @bucket = Puppet::FileBucket::Dipper.new(:Path => Puppet[:clientbucketdir])
    end

    def rails_resources
        collector.send(:collect_exported)
    end

    def write(target, resources)
        # Skip the nagios type when we have no resources and no existing
        # file.
        return if resources.empty? and ! FileTest.exist?(target)

        dir = File.dirname(target)
        unless FileTest.exist?(dir)
            FileUtils.mkdir_p(dir)
        end

        count = 0

        tempfile = target + ".tmp"
        File.open(tempfile, "w") do |file|
            resources.each do |resource|
                count += 1
                file.puts resource.to_nagios.to_s.gsub("_naginator_name", Puppet::Provider::Naginator::NAME_STRING)
            end
        end

        if $options[:compare]
            if FileTest.exist?(target) and File.read(tempfile) == File.read(target)
                return false
            end
        end

        backup(target)

        # Atomic rename
        File.rename(tempfile, target)

        Puppet.notice "Wrote %s resources to %s" % [count, target]

        return true
    ensure
        File.unlink(tempfile) if tempfile and FileTest.exist?(tempfile)
    end
end

arguments = [
    [ "--compare", "-c", GetoptLong::NO_ARGUMENT ],
    [ "--debug",   "-d", GetoptLong::NO_ARGUMENT ],
    [ "--verbose", "-v", GetoptLong::NO_ARGUMENT ],
    [ "--help",    "-h", GetoptLong::NO_ARGUMENT ]
]

Puppet.settings.addargs(arguments)

result = GetoptLong.new(*arguments)

$options = {}
result.each { |opt,arg|
    case opt
        when "--help"
            begin
                require 'rdoc/usage'
                RDoc::usage && exit
            rescue LoadError
                docs = []
                File.readlines(__FILE__).each do |line|
                    next if line =~ /^#\!/
                    unless line =~ /^#/
                        next if docs.length == 0 # skip the first line or so
                        break # else, we've passed the docs, so just break
                    end
                    docs << line.sub(/^# ?/, '')
                end

                print docs
                exit
            end
        when "--compare"
            $options[:compare] = true
        when "--verbose"
            $options[:verbose] = true
        when "--debug"
            $options[:debug] = true
        when "--debug"
            $options[:debug] = true
    else
            Puppet.settings.handlearg(opt, arg)
    end
}

# Read in Puppet settings, so we know how Puppet's configured.
Puppet.initialize_settings

Puppet::Util::Log.newdestination(:console)

if $options[:debug]
    Puppet::Util::Log.level = :debug
elsif $options[:verbose]
    Puppet::Util::Log.level = :info
end

# See if Naginator is installed directly, else load Puppet's version.
begin
    require 'nagios'
rescue LoadError
    require 'puppet/external/nagios'
end

changed = false
Nagios::Base.eachtype do |name, type|
    writer = NagiosWriter.new(name)

    changed = true if writer.evaluate
end

if $options[:compare] and changed
    exit(1)
else
    exit(0)
end

