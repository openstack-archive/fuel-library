#!/bin/bash
#
# Resource script for haproxy daemon
#
# Description:  Manages haproxy daemon as an OCF resource in
#               an High Availability setup.
#
# HAProxy OCF script's Author: Russki
# Rsync OCF script's Author: Dhairesh Oza <odhairesh@novell.com>
# License: GNU General Public License (GPL)
#
#
#	usage: $0 {start|stop|status|monitor|validate-all|meta-data}
#
#	The "start" arg starts haproxy.
#
#	The "stop" arg stops it.
#
# OCF parameters:
# OCF_RESKEY_binpath
# OCF_RESKEY_conffile
# OCF_RESKEY_extraconf
#
# Note:This RA requires that the haproxy config files has a "pidfile"
# entry so that it is able to act on the correct process
##########################################################################
# Initialization:

if [ "${OCF_ROOT}" = '' ]; then
  OCF_ROOT="/usr/lib/ocf"
fi

OCF_RESKEY_ns_default="haproxy"
OCF_RESKEY_conffile_default="/etc/haproxy/haproxy.cfg"
OCF_RESKEY_pidfile_default="/var/run/haproxy.pid"
OCF_RESKEY_binpath_default="/usr/sbin/haproxy"

: ${OCF_RESKEY_ns=${OCF_RESKEY_ns_default}}
: ${OCF_RESKEY_conffile=${OCF_RESKEY_conffile_default}}
: ${OCF_RESKEY_pidfile=${OCF_RESKEY_pidfile_default}}
: ${OCF_RESKEY_binpath=${OCF_RESKEY_binpath_default}}
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/resource.d/heartbeat}
. ${OCF_FUNCTIONS_DIR}/.ocf-shellfuncs

USAGE="Usage: $0 {start|stop|restart|status|monitor|validate-all|meta-data}";

RUN_IN_NS="ip netns exec $OCF_RESKEY_ns "
if [[ -z $OCF_RESKEY_ns ]] ; then
	RUN=''
else
	RUN="$RUN_IN_NS "
fi

##########################################################################

usage()
{
	echo $USAGE >&2
}

meta_data()
{
cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="haproxy">
<version>1.0</version>
<longdesc lang="en">
This script manages haproxy daemon
</longdesc>
<shortdesc lang="en">Manages an haproxy daemon</shortdesc>

<parameters>

<parameter name="binpath">
<longdesc lang="en">
The haproxy binary path.
For example, "/usr/sbin/haproxy"
</longdesc>
<shortdesc lang="en">Full path to the haproxy binary</shortdesc>
<content type="string" default="/usr/sbin/haproxy"/>
</parameter>

<parameter name="conffile">
<longdesc lang="en">
The haproxy daemon configuration file name with full path.
For example, "/etc/haproxy/haproxy.cfg"
</longdesc>
<shortdesc lang="en">Configuration file name with full path</shortdesc>
<content type="string" default="/etc/haproxy/haproxy.cfg" />
</parameter>

<parameter name="ns">
<longdesc lang="en">
Name of network namespace.\n
Should be present.
</longdesc>
<shortdesc lang="en">Name of network namespace.</shortdesc>
<content type="string" default="$OCF_RESKEY_ns_default"/>
</parameter>

<parameter name="extraconf">
<longdesc lang="en">
Extra command line arguments to pass to haproxy.
For example, "-f /etc/haproxy/shared.cfg"
</longdesc>
<shortdesc lang="en">Extra command line arguments for haproxy</shortdesc>
<content type="string" default="" />
</parameter>

</parameters>

<actions>
<action name="start" timeout="20s"/>
<action name="stop" timeout="20s"/>
<action name="reload" timeout="20s"/>
<action name="monitor" depth="0" timeout="20s" interval="60s" />
<action name="validate-all" timeout="20s"/>
<action name="meta-data"  timeout="5s"/>
</actions>
</resource-agent>
END
exit $OCF_SUCCESS
}

check_ns() {
  local ns=`ip netns list | grep "$OCF_RESKEY_ns"`
  [[ $ns != $OCF_RESKEY_ns ]] && return $OCF_ERR_GENERIC
  return $OCF_SUCCESS
}

get_ns() {
  local rc
  check_ns && return $OCF_SUCCESS

  ocf_run ip netns add $OCF_RESKEY_ns
  rc=$?
  ocf_run $RUN_IN_NS ip link set up dev lo

  return $rc
}

get_variables() {
	get_ns
	CONF_FILE="${OCF_RESKEY_conffile}"
	COMMAND="$RUN ${OCF_RESKEY_binpath}"
	if [ -n "${OCF_RESKEY_pidfile}" ]; then
		PIDFILE=$(grep -v "#" ${CONF_FILE} | grep "pidfile" | sed 's/^[ \t]*pidfile[ \t]*//')
	else
		PIDFILE="${OCF_RESKEY_pidfile}"
	fi
}

set_ns_routing() {
  HOST_INTERFACE="hapr-host"
  NS_INTERFACE="hapr-ns"
  NS="${OCF_RESKEY_ns}"
  HOST_IP="240.0.0.1"
  NS_IP="240.0.0.2"
  MASK="30"
  METRIC="10000"

  nsip() {
    ip netns exec "${NS}" ip ${@}
  }

  # create host-ns veth pair unless it's present
  ip link | grep -q "${HOST_INTERFACE}:"
  if [ $? -gt 0 ]; then
    ip link add "${HOST_INTERFACE}" type veth peer name "${NS_INTERFACE}"
  fi

  # move the ns part to the namespace
  ip link | grep -q "${NS_INTERFACE}:"
  if [ $? -eq 0 ]; then
    ip link set dev "${NS_INTERFACE}" netns "${NS}"
  fi

  # up the host part
  ip link set "${HOST_INTERFACE}" up

  # set host part's ip
  ip addr show dev "${HOST_INTERFACE}" | grep -q "inet ${HOST_IP}/${MASK}"
  if [ $? -gt 0 ]; then
    ip addr add "${HOST_IP}/${MASK}" dev "${HOST_INTERFACE}"
  fi

  # up the ns part
  nsip link set "${NS_INTERFACE}" up

  # set ns part's ip
  nsip addr show dev "${NS_INTERFACE}" | grep -q "inet ${NS_IP}/${MASK}"
  if [ $? -gt 0 ]; then
    nsip addr add "${NS_IP}/${MASK}" dev "${NS_INTERFACE}"
  fi

  # set default gateway inside ns
  nsip route list | grep -q "default via ${HOST_IP}"
  if [ $? -gt 0 ]; then
    nsip route add default via "${HOST_IP}" metric "${METRIC}"
  fi

  # set masquerade on host node
  iptables -t nat -L | grep -q masquerade-for-haproxy-namespace
  if [ $? -gt 0 ]; then
    iptables -t nat -A POSTROUTING -s "${NS_IP}" -j MASQUERADE -m comment --comment "masquerade-for-haproxy-namespace"
  fi
}

haproxy_status() {
	get_variables
	if [ -n "${PIDFILE}" -a -f "${PIDFILE}" ]; then
		# haproxy is probably running
		# get pid from pidfile
		PID="`cat ${PIDFILE}`"
		if [ -n "${PID}" ]; then
			# check if process exists
			if $RUN ps -p "${PID}" | grep -q haproxy; then
				ocf_log info "haproxy daemon running"
				return $OCF_SUCCESS
			else
				ocf_log info "haproxy daemon is not running but pid file exists"
				return $OCF_NOT_RUNNING
			fi
		else
			ocf_log err "PID file empty!"
			return $OCF_ERR_GENERIC
		fi
	fi
	# haproxy is not running
	ocf_log info "haproxy daemon is not running"
	return $OCF_NOT_RUNNING
}

haproxy_start()
{
	get_variables
	# if haproxy is running return success
	haproxy_status
	retVal=$?
	if [ $retVal -eq $OCF_SUCCESS ]; then
		return $OCF_SUCCESS
	elif [ $retVal -ne $OCF_NOT_RUNNING ]; then
		ocf_log err "Error. Unknown status."
		return $OCF_ERR_GENERIC
	fi

	# run the haproxy binary
	ocf_run ${COMMAND} ${OCF_RESKEY_extraconf} -f "${CONF_FILE}" -p "${PIDFILE}"
	if [ $? -ne 0 ]; then
		ocf_log err "Error. haproxy daemon returned error $?."
		return $OCF_ERR_GENERIC
	fi

	if [ "${OCF_RESKEY_ns}" != '' ]; then
		set_ns_routing
	fi

	ocf_log info "Started haproxy daemon."
	return $OCF_SUCCESS
}

haproxy_reload()
{
	get_variables
	if haproxy_status; then
		# get pid from pidfile
		PID="`cat ${PIDFILE}`"
		# reload haproxy binary replacing the old process
		ocf_run ${COMMAND} ${OCF_RESKEY_extraconf} -f "${CONF_FILE}" -p "${PIDFILE}" -sf "${PID}"
		if [ $? -ne 0 ]; then
			ocf_log err "Error. haproxy daemon returned error $?."
			return $OCF_ERR_GENERIC
		fi
	else
		ocf_log info "Haproxy daemon is not running. Starting it."
		haproxy_start
	fi
}

haproxy_stop()
{
	get_variables
	if haproxy_status ; then
		PID="`${RUN} cat ${PIDFILE}`"
		if [ -n "${PID}" ] ; then
			kill "${PID}"
			if [ $? -ne 0 ]; then
				kill -SIGKILL "${PID}"
				if [ $? -ne 0 ]; then
					ocf_log err "Error. Could not stop haproxy daemon."
					return $OCF_ERR_GENERIC
				fi
			fi
			rm -f "${PIDFILE}"
		fi
	fi
	ocf_log info "Stopped haproxy daemon."
	return $OCF_SUCCESS
}

haproxy_monitor()
{
	haproxy_status
}

haproxy_validate_all()
{
	get_variables
	if [ -n "$OCF_RESKEY_binpath" -a ! -x "$OCF_RESKEY_binpath" ]; then
		ocf_log err "Binary path $OCF_RESKEY_binpath does not exist."
		return $OCF_ERR_ARGS
	fi
	if [ -n "$OCF_RESKEY_conffile" -a ! -f "$OCF_RESKEY_conffile" ]; then
		ocf_log err "Config file $OCF_RESKEY_conffile does not exist."
		return $OCF_ERR_ARGS
	fi

	if  grep -v "^#" "$CONF_FILE" | grep "pidfile" > /dev/null ; then
		:
	else
		ocf_log err "Error. \"pidfile\" entry required in the haproxy config file by haproxy OCF RA."
		return $OCF_ERR_GENERIC
	fi

	return $OCF_SUCCESS
}

haproxy_restart()
{
	haproxy_stop
	haproxy_start
}

#
# Main
#

if [ $# -ne 1 ]; then
	usage
	exit $OCF_ERR_ARGS
fi

case $1 in
	start) haproxy_start
	;;

	stop) haproxy_stop
	;;

	reload) haproxy_reload
	;;

	restart) haproxy_restart
	;;

	status)	haproxy_status
	;;

	monitor) haproxy_monitor
	;;

	validate-all) haproxy_validate_all
	;;

	meta-data) meta_data
	;;

	usage) usage; exit $OCF_SUCCESS
	;;

	*) usage; exit $OCF_ERR_UNIMPLEMENTED
	;;
esac
